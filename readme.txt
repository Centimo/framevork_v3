Описание решения.
Из постановки задачи ясно, что частицы между собой не взаимодействуют. Отсюда вытекает, что их обработку легко разбить на несколько параллельных потоков.
Для каждого потока должны быть доступны следующие внешние действия:
1) Чтение всех частиц для их дальнейшего отображения. Подразумевает только чтение.
2) Добавление новых частиц
 
Добавление новых частиц должно происходить независимо от работы потока, поэтому логично для этого выделить очередь. Пользователь и другие потоки будут добавлять частицы в очередь, а поток-хозяин считывать их по мере возможности. Для этого был реализован класс Atomic_queue фиксированного размера. Представляет из себя циклический буфер с атомарными счётчиками. Так как каждый элемент очереди - координаты взрыва, то появилась возможность использовать легковесный контейнер, позволяющий одновременно читать и писать - RCU_cell_light. RCU_cell_light является простым контейнером для хранения одного элемента с возможностью множественного чтения и единичной записи одновременно. Реализован по образу схемы RCU. Использование данного класса позволяет гарантировать отсутствие гонки данных при переполнении очереди.

Чтение всех частиц происходит только одним потоком - рендером, а сами частицы обрабатываются только потоком-хозяином. Таким образом имеем одного писателя и одного читателя. Для этой ситуации был реализован OROW_vector. Представляет из себя вектор, разбитый на части. Для избежания гонки данных используется подобие RCU схемы: вектор выделяется с двумя дополнительными частями (элементов в нём больше, чем указывается в конструкторе). Когда происходит чтение, читающий поток изменяет атомарный указатель и таким образом оповещает "писателя" какая часть в данный момент читается. Поток-писатель имеет доступ к двум свободным ячейкам (в отличие от "читателя", который не имеет доступа к их указателям), и сверив их указатели с указателем текущего чтения (он может совпадать с одним из свободных, так как читатель мог не успеть получить "свежую" версию), выбирает незанятую часть и переносит данные в неё. В итоге контейнер позволяет проводить wait-free чтение и запись.

Класс Engine хранит в себе данные потоков (в том числе общие для всех потоков) и предоставляет интерфейс для внешних пользователей.
Стоит отметить также наличие у каждого потока отдельной очереди для пользовательских команд (взрывов). Это было сделано для того, чтобы в случае большой нагрузки действия пользователя не затирались при переполнении основной очереди. Каждый поток первым делом запрашивает данные именно из очереди пользовательских команд.