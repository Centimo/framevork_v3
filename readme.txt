Описание решения.
Из постановки задачи ясно, что частицы между собой не взаимодействуют. Отсюда вытекает, что их обработку легко разбить на несколько параллельных потоков.
Для каждого потока должны быть доступны следующие внешние действия:
1) Чтение всех частиц для их дальнейшего отображения. Подразумевает только чтение.
2) Добавление новых частиц
 
Добавление новых частиц должно происходить независимо от работы потока, поэтому логично для этого выделить очередь. Пользователь и другие потоки будут добавлять частицы в очередь, а поток-хозяин считывать их по мере возможности. Для этого был реализован класс Atomic_queue фиксированного размера. Представляет из себя циклический буфер с атомарными счётчиками. Для предотвращения гонки данных Atomic_queue формируется с избыточной длиной (количество элементов вектора), пропорциональной количеству потоков.

Чтение всех частиц происходит только одним потоком - рендером, а сами частицы обрабатываются только потоком-хозяином. Таким образом имеем одного писателя и одного читателя. Для этой ситуации был реализован OROW_vector. Представляет из себя вектор, разбитый на части. Для избежания гонки данных используется подобие RCU схемы: вектор выделяется с двумя дополнительными частями (элементов в нём больше, чем указывается в конструкторе). Когда происходит чтение, читающий поток изменяет атомарный указатель и таким образом оповещает "писателя" какая часть в данный момент читается. Поток-писатель имеет доступ к двум свободным ячейкам (в отличие от "читателя", который не имеет доступа к их указателям), и сверив их указатели с указателем текущего чтения (он может совпадать с одним из свободных, так как читатель мог не успеть получить "свежую" версию), выбирает незанятую часть и переносит данные в неё. В итоге контейнер позволяет проводить wait-free чтение и запись.

Класс Engine хранит в себе данные потоков (в том числе общие для всех потоков) и предоставляет интерфейс для внешних пользователей.
Стоит отметить также наличие у каждого потока отдельной очереди для пользовательских команд (взрывов). Это было сделано для того, чтобы в случае большой нагрузки действия пользователя не затирались при переполнении основной очереди. Каждый поток первым делом запрашивает данные именно из очереди пользовательских команд.
Синхронизация времени производится отдельным потоком, который считает прошедшее время и отправляет разницу в Engine. Также этот поток выводит диагностическую информацию. Отдельный поток выделен для того, что не зависеть от таймера glut.
Для того, чтобы заменять наиболее "старые" частицы (а не случайные или первые в векторе), создан Particles_by_lifetime_counter. На каждой итерации обработки частиц, его экземпляр подсчитывает распределение частиц по времени жизни, а затем определяет частицы старше какого времени могут быть заменены.